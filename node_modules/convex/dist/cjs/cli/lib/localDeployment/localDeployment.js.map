{
  "version": 3,
  "sources": ["../../../../../src/cli/lib/localDeployment/localDeployment.ts"],
  "sourcesContent": ["import { Context, logVerbose } from \"../../../bundler/context.js\";\nimport detect from \"detect-port\";\nimport {\n  bigBrainPause,\n  bigBrainRecordActivity,\n  bigBrainStart,\n} from \"./bigBrain.js\";\nimport {\n  LocalDeploymentConfig,\n  loadDeploymentConfig,\n  rootDeploymentStateDir,\n  saveDeploymentConfig,\n} from \"./filePaths.js\";\nimport {\n  ensureBackendBinaryDownloaded,\n  ensureBackendRunning,\n  ensureBackendStopped,\n  localDeploymentUrl,\n  runLocalBackend,\n} from \"./run.js\";\nimport { handlePotentialUpgrade } from \"./upgrade.js\";\nimport { OnDeploymentActivityFunc } from \"../deployment.js\";\nimport { promptSearch } from \"../utils/prompts.js\";\n\nexport type DeploymentDetails = {\n  deploymentName: string;\n  deploymentUrl: string;\n  adminKey: string;\n  onActivity: OnDeploymentActivityFunc;\n};\n\nexport async function handleLocalDeployment(\n  ctx: Context,\n  options: {\n    teamSlug: string;\n    projectSlug: string;\n    ports?: {\n      cloud: number;\n      site: number;\n    };\n    backendVersion?: string;\n    forceUpgrade: boolean;\n  },\n): Promise<DeploymentDetails> {\n  if (await isOffline()) {\n    return handleOffline(ctx, options);\n  }\n\n  const existingDeploymentForProject = await getExistingDeployment(ctx, {\n    projectSlug: options.projectSlug,\n    teamSlug: options.teamSlug,\n  });\n  if (existingDeploymentForProject !== null) {\n    logVerbose(\n      ctx,\n      `Found existing deployment for project ${options.projectSlug}`,\n    );\n    // If it's still running for some reason, exit and tell the user to kill it.\n    // It's fine if a different backend is running on these ports though since we'll\n    // pick new ones.\n    await ensureBackendStopped(ctx, {\n      ports: {\n        cloud: existingDeploymentForProject.config.ports.cloud,\n      },\n      maxTimeSecs: 5,\n      deploymentName: existingDeploymentForProject.deploymentName,\n      allowOtherDeployments: true,\n    });\n  }\n\n  const { binaryPath, version } = await ensureBackendBinaryDownloaded(\n    ctx,\n    options.backendVersion === undefined\n      ? {\n          kind: \"latest\",\n        }\n      : { kind: \"version\", version: options.backendVersion },\n  );\n  const ports = await choosePorts(ctx, options.ports);\n  const { deploymentName, adminKey } = await bigBrainStart(ctx, {\n    port: ports.cloud,\n    projectSlug: options.projectSlug,\n    teamSlug: options.teamSlug,\n    instanceName: existingDeploymentForProject?.deploymentName ?? null,\n  });\n  const onActivity = async (isOffline: boolean, _wasOffline: boolean) => {\n    await ensureBackendRunning(ctx, {\n      cloudPort: ports.cloud,\n      deploymentName,\n      maxTimeSecs: 5,\n    });\n    if (isOffline) {\n      return;\n    }\n    await bigBrainRecordActivity(ctx, {\n      instanceName: deploymentName,\n    });\n  };\n\n  const { cleanupHandle } = await handlePotentialUpgrade(ctx, {\n    deploymentName,\n    oldVersion: existingDeploymentForProject?.config.backendVersion ?? null,\n    newBinaryPath: binaryPath,\n    newVersion: version,\n    ports,\n    adminKey,\n    forceUpgrade: options.forceUpgrade,\n  });\n\n  const cleanupFunc = ctx.removeCleanup(cleanupHandle);\n  ctx.registerCleanup(async () => {\n    if (cleanupFunc !== null) {\n      await cleanupFunc();\n    }\n    await bigBrainPause(ctx, {\n      projectSlug: options.projectSlug,\n      teamSlug: options.teamSlug,\n    });\n  });\n\n  return {\n    adminKey,\n    deploymentName,\n    deploymentUrl: localDeploymentUrl(ports.cloud),\n    onActivity,\n  };\n}\n\nasync function handleOffline(\n  ctx: Context,\n  options: {\n    teamSlug: string;\n    projectSlug: string;\n    ports?: { cloud: number; site: number };\n  },\n): Promise<DeploymentDetails> {\n  const { deploymentName, config } =\n    await chooseFromExistingLocalDeployments(ctx);\n  const { binaryPath } = await ensureBackendBinaryDownloaded(ctx, {\n    kind: \"version\",\n    version: config.backendVersion,\n  });\n  const ports = await choosePorts(ctx, options.ports);\n  saveDeploymentConfig(ctx, deploymentName, config);\n  await runLocalBackend(ctx, {\n    binaryPath,\n    ports,\n    deploymentName,\n  });\n  return {\n    adminKey: config.adminKey,\n    deploymentName,\n    deploymentUrl: localDeploymentUrl(ports.cloud),\n    onActivity: async (isOffline: boolean, wasOffline: boolean) => {\n      await ensureBackendRunning(ctx, {\n        cloudPort: ports.cloud,\n        deploymentName,\n        maxTimeSecs: 5,\n      });\n      if (isOffline) {\n        return;\n      }\n      if (wasOffline) {\n        await bigBrainStart(ctx, {\n          port: ports.cloud,\n          projectSlug: options.projectSlug,\n          teamSlug: options.teamSlug,\n          instanceName: deploymentName,\n        });\n      }\n      await bigBrainRecordActivity(ctx, {\n        instanceName: deploymentName,\n      });\n    },\n  };\n}\n\nasync function getExistingDeployment(\n  ctx: Context,\n  options: {\n    projectSlug: string;\n    teamSlug: string;\n  },\n): Promise<{ deploymentName: string; config: LocalDeploymentConfig } | null> {\n  const { projectSlug, teamSlug } = options;\n  const prefix = `local-${teamSlug.replace(/-/g, \"_\")}-${projectSlug.replace(/-/g, \"_\")}`;\n  const localDeployments = await getLocalDeployments(ctx);\n  const existingDeploymentForProject = localDeployments.find((d) =>\n    d.deploymentName.startsWith(prefix),\n  );\n  if (existingDeploymentForProject === undefined) {\n    return null;\n  }\n  return {\n    deploymentName: existingDeploymentForProject.deploymentName,\n    config: existingDeploymentForProject.config,\n  };\n}\n\nasync function getLocalDeployments(ctx: Context): Promise<\n  Array<{\n    deploymentName: string;\n    config: LocalDeploymentConfig;\n  }>\n> {\n  const dir = rootDeploymentStateDir();\n  if (!ctx.fs.exists(dir)) {\n    return [];\n  }\n  const deploymentNames = ctx.fs.listDir(dir).map((d) => d.name);\n  return deploymentNames.flatMap((deploymentName) => {\n    const config = loadDeploymentConfig(ctx, deploymentName);\n    if (config !== null) {\n      return [{ deploymentName, config }];\n    }\n    return [];\n  });\n}\n\nasync function chooseFromExistingLocalDeployments(ctx: Context): Promise<{\n  deploymentName: string;\n  config: LocalDeploymentConfig;\n}> {\n  const localDeployments = await getLocalDeployments(ctx);\n  return promptSearch(ctx, {\n    message: \"Choose from an existing local deployment?\",\n    choices: localDeployments.map((d) => ({\n      name: d.deploymentName,\n      value: d,\n    })),\n  });\n}\n\nasync function choosePorts(\n  ctx: Context,\n  requestedPorts?: {\n    cloud: number;\n    site: number;\n  },\n): Promise<{ cloud: number; site: number }> {\n  if (requestedPorts !== undefined) {\n    const availableCloudPort = await detect(requestedPorts.cloud);\n    const availableSitePort = await detect(requestedPorts.site);\n    if (\n      availableCloudPort !== requestedPorts.cloud ||\n      availableSitePort !== requestedPorts.site\n    ) {\n      return ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: \"Requested ports are not available\",\n      });\n    }\n    return { cloud: availableCloudPort, site: availableSitePort };\n  }\n  const availableCloudPort = await detect(3210);\n  const availableSitePort = await detect(availableCloudPort + 1);\n  return { cloud: availableCloudPort, site: availableSitePort };\n}\n\nasync function isOffline(): Promise<boolean> {\n  // TODO(ENG-7080) -- implement this for real\n  return false;\n}\n"],
  "mappings": "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",
  "names": ["isOffline", "availableCloudPort", "detect", "availableSitePort"]
}
