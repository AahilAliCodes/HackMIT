{
  "version": 3,
  "sources": ["../../../../../src/cli/lib/localDeployment/run.ts"],
  "sourcesContent": ["import AdmZip from \"adm-zip\";\nimport { Context, logMessage, logVerbose } from \"../../../bundler/context.js\";\nimport {\n  binariesDir,\n  binaryZip,\n  deploymentStateDir,\n  executablePath,\n  versionedBinaryDir,\n} from \"./filePaths.js\";\nimport path from \"path\";\nimport child_process from \"child_process\";\nimport { promisify } from \"util\";\nimport { Readable } from \"stream\";\nimport { nodeFs } from \"../../../bundler/fs.js\";\nimport detect from \"detect-port\";\n\nconst LOCAL_BACKEND_INSTANCE_SECRET =\n  \"4361726e697461732c206c69746572616c6c79206d65616e696e6720226c6974\";\n\nexport async function ensureBackendBinaryDownloaded(\n  ctx: Context,\n  version: { kind: \"latest\" } | { kind: \"version\"; version: string },\n): Promise<{ binaryPath: string; version: string }> {\n  if (version.kind === \"version\") {\n    logVerbose(\n      ctx,\n      `Ensuring backend binary downloaded for version ${version.version}`,\n    );\n    const existingDownload = await checkForExistingDownload(\n      ctx,\n      version.version,\n    );\n    if (existingDownload !== null) {\n      logVerbose(ctx, `Using existing download at ${existingDownload}`);\n      return {\n        binaryPath: existingDownload,\n        version: version.version,\n      };\n    }\n    const binaryPath = await downloadBinary(ctx, version.version);\n    return { version: version.version, binaryPath };\n  }\n\n  logVerbose(ctx, `Ensuring latest backend binary downloaded`);\n  const latest = await fetch(\n    \"https://github.com/get-convex/convex-backend/releases/latest\",\n    { redirect: \"manual\" },\n  );\n  if (latest.status !== 302) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: \"Failed to get latest convex backend release\",\n      errForSentry: \"Failed to get latest convex backend release\",\n    });\n  }\n  const latestUrl = latest.headers.get(\"location\")!;\n  const latestVersion = latestUrl.split(\"/\").pop()!;\n  logVerbose(ctx, `Latest version is ${latestVersion}`);\n  return ensureBackendBinaryDownloaded(ctx, {\n    kind: \"version\",\n    version: latestVersion,\n  });\n}\n\n/**\n *\n * @param ctx\n * @param version\n * @returns The binary path if it exists, or null\n */\nasync function checkForExistingDownload(\n  ctx: Context,\n  version: string,\n): Promise<string | null> {\n  const destDir = versionedBinaryDir(version);\n  if (!ctx.fs.exists(destDir)) {\n    return null;\n  }\n  const p = executablePath(version);\n  if (!ctx.fs.exists(p)) {\n    // This directory isn't what we expected. Remove it.\n    ctx.fs.rmdir(destDir);\n    return null;\n  }\n  await promisify(child_process.exec)(`chmod +x ${p}`);\n  return p;\n}\n\nasync function downloadBinary(ctx: Context, version: string): Promise<string> {\n  const downloadPath = getDownloadPath();\n  if (downloadPath === null) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Unsupported platform ${process.platform} and architecture ${process.arch} for local deployment.`,\n    });\n  }\n  const response = await fetch(\n    `https://github.com/get-convex/convex-backend/releases/download/${version}/${downloadPath}`,\n  );\n  logMessage(ctx, \"Downloading convex backend\");\n  if (!ctx.fs.exists(binariesDir())) {\n    ctx.fs.mkdir(binariesDir(), { recursive: true });\n  }\n  const zipLocation = binaryZip();\n  if (ctx.fs.exists(zipLocation)) {\n    ctx.fs.unlink(zipLocation);\n  }\n  const readable = Readable.fromWeb(response.body! as any);\n  await nodeFs.writeFileStream(zipLocation, readable);\n  logVerbose(ctx, \"Downloaded zip file\");\n\n  const zip = new AdmZip(zipLocation);\n  const versionDir = versionedBinaryDir(version);\n  zip.extractAllTo(versionDir, true);\n  logVerbose(ctx, \"Extracted from zip file\");\n  const p = executablePath(version);\n  await promisify(child_process.exec)(`chmod +x ${p}`);\n  logVerbose(ctx, \"Marked as executable\");\n  return p;\n}\n\nexport async function runLocalBackend(\n  ctx: Context,\n  args: {\n    ports: {\n      cloud: number;\n      site: number;\n    };\n    deploymentName: string;\n    binaryPath: string;\n  },\n): Promise<{\n  cleanupHandle: string;\n}> {\n  const { ports } = args;\n  const deploymentDir = deploymentStateDir(args.deploymentName);\n  ctx.fs.mkdir(deploymentDir, { recursive: true });\n  const commandArgs = [\n    \"--port\",\n    ports.cloud.toString(),\n    \"--site-proxy-port\",\n    ports.site.toString(),\n    \"--instance-name\",\n    args.deploymentName,\n    \"--instance-secret\",\n    LOCAL_BACKEND_INSTANCE_SECRET,\n    \"--local-storage\",\n    path.join(deploymentDir, \"convex_local_storage\"),\n    path.join(deploymentDir, \"convex_local_backend.sqlite3\"),\n  ];\n  const commandStr = `${args.binaryPath} ${commandArgs.join(\" \")}`;\n  logVerbose(ctx, `Starting local backend: \\`${commandStr}\\``);\n  const p = child_process\n    .spawn(args.binaryPath, commandArgs, { stdio: \"ignore\" })\n    .on(\"exit\", (code) => {\n      logVerbose(\n        ctx,\n        `Local backend exited with code ${code}, full command \\`${commandStr}\\``,\n      );\n    });\n  const cleanupHandle = ctx.registerCleanup(async () => {\n    logVerbose(ctx, `Stopping local backend on port ${ports.cloud}`);\n    p.kill(\"SIGTERM\");\n  });\n\n  await ensureBackendRunning(ctx, {\n    cloudPort: ports.cloud,\n    deploymentName: args.deploymentName,\n    maxTimeSecs: 10,\n  });\n\n  return {\n    cleanupHandle,\n  };\n}\n\nexport async function ensureBackendRunning(\n  ctx: Context,\n  args: {\n    cloudPort: number;\n    deploymentName: string;\n    maxTimeSecs: number;\n  },\n): Promise<void> {\n  logVerbose(\n    ctx,\n    `Ensuring backend running on port ${args.cloudPort} is running`,\n  );\n  const deploymentUrl = localDeploymentUrl(args.cloudPort);\n  let timeElapsedSecs = 0;\n  while (timeElapsedSecs < args.maxTimeSecs) {\n    try {\n      const resp = await fetch(`${deploymentUrl}/instance_name`);\n      if (resp.status === 200) {\n        const text = await resp.text();\n        if (text !== args.deploymentName) {\n          return await ctx.crash({\n            exitCode: 1,\n            errorType: \"fatal\",\n            printedMessage: `A different local backend ${text} is running on selected port ${args.cloudPort}`,\n          });\n        }\n        break;\n      } else {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        timeElapsedSecs += 0.5;\n      }\n    } catch {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      timeElapsedSecs += 0.5;\n    }\n  }\n}\n\nexport async function ensureBackendStopped(\n  ctx: Context,\n  args: {\n    ports: {\n      cloud: number;\n      site?: number;\n    };\n    maxTimeSecs: number;\n    deploymentName: string;\n    // Whether to allow a deployment with a different name to run on this port\n    allowOtherDeployments: boolean;\n  },\n) {\n  logVerbose(\n    ctx,\n    `Ensuring backend running on port ${args.ports.cloud} is stopped`,\n  );\n  let timeElapsedSecs = 0;\n  while (timeElapsedSecs < args.maxTimeSecs) {\n    const cloudPort = await detect(args.ports.cloud);\n    const sitePort =\n      args.ports.site === undefined ? undefined : await detect(args.ports.site);\n    // Both ports are free\n    if (cloudPort === args.ports.cloud && sitePort === args.ports.site) {\n      return;\n    }\n    try {\n      const instanceNameResp = await fetch(\n        `${localDeploymentUrl(args.ports.cloud)}/instance_name`,\n      );\n      if (instanceNameResp.ok) {\n        const instanceName = await instanceNameResp.text();\n        if (instanceName !== args.deploymentName) {\n          if (args.allowOtherDeployments) {\n            return;\n          }\n          return await ctx.crash({\n            exitCode: 1,\n            errorType: \"fatal\",\n            printedMessage: `A different local backend ${instanceName} is running on selected port ${args.ports.cloud}`,\n          });\n        }\n      }\n    } catch (error: any) {\n      logVerbose(ctx, `Error checking if backend is running: ${error.message}`);\n      // Backend is probably not running\n      continue;\n    }\n    await new Promise((resolve) => setTimeout(resolve, 500));\n    timeElapsedSecs += 0.5;\n  }\n  return ctx.crash({\n    exitCode: 1,\n    errorType: \"fatal\",\n    printedMessage: `A local backend is still running on port ${args.ports.cloud}. Please stop it and run this command again.`,\n  });\n}\n\nexport function localDeploymentUrl(cloudPort: number): string {\n  return `http://127.0.0.1:${cloudPort}`;\n}\n\nfunction getDownloadPath() {\n  switch (process.platform) {\n    case \"darwin\":\n      if (process.arch === \"arm64\") {\n        return \"convex-local-backend-aarch64-apple-darwin.zip\";\n      } else if (process.arch === \"x64\") {\n        return \"convex-local-backend-x86_64-apple-darwin.zip\";\n      }\n      break;\n    case \"linux\":\n      if (process.arch === \"arm64\") {\n        return \"convex-local-backend-aarch64-unknown-linux-gnu.zip\";\n      } else if (process.arch === \"x64\") {\n        return \"convex-local-backend-x86_64-unknown-linux-gnu.zip\";\n      }\n      break;\n    case \"win32\":\n      return \"convex-local-backend-x86_64-pc-windows-msvc.zip\";\n  }\n  return null;\n}\n"],
  "mappings": "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",
  "names": ["child_process", "AdmZip", "path", "detect"]
}
