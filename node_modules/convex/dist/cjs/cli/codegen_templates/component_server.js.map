{
  "version": 3,
  "sources": ["../../../../src/cli/codegen_templates/component_server.ts"],
  "sourcesContent": ["import {\n  ComponentDirectory,\n  toComponentDefinitionPath,\n} from \"../lib/components/definition/directoryStructure.js\";\nimport {\n  ComponentExports,\n  EvaluatedComponentDefinition,\n} from \"../lib/deployApi/componentDefinition.js\";\nimport { Identifier, Reference } from \"../lib/deployApi/types.js\";\nimport { StartPushResponse } from \"../lib/deployApi/startPush.js\";\nimport {\n  ConvexValidator,\n  convexValidator,\n} from \"../lib/deployApi/validator.js\";\nimport { header } from \"./common.js\";\nimport { Context } from \"../../bundler/context.js\";\nimport { CanonicalizedModulePath } from \"../lib/deployApi/paths.js\";\nimport { Value, jsonToConvex } from \"../../values/value.js\";\nimport { z } from \"zod\";\nimport { encodeDefinitionPath } from \"../lib/components/definition/bundle.js\";\n\nexport function componentServerJS(): string {\n  const result = `\n  ${header(\n    \"Generated utilities for implementing server-side Convex query and mutation functions.\",\n  )}\n  import {\n    actionGeneric,\n    httpActionGeneric,\n    queryGeneric,\n    mutationGeneric,\n    internalActionGeneric,\n    internalMutationGeneric,\n    internalQueryGeneric,\n    componentsGeneric,\n  } from \"convex/server\";\n\n  /**\n   * Define a query in this Convex app's public API.\n   *\n   * This function will be allowed to read your Convex database and will be accessible from the client.\n   *\n   * @param func - The query function. It receives a {@link QueryCtx} as its first argument.\n   * @returns The wrapped query. Include this as an \\`export\\` to name it and make it accessible.\n   */\n  export const query = queryGeneric;\n\n  /**\n   * Define a query that is only accessible from other Convex functions (but not from the client).\n   *\n   * This function will be allowed to read from your Convex database. It will not be accessible from the client.\n   *\n   * @param func - The query function. It receives a {@link QueryCtx} as its first argument.\n   * @returns The wrapped query. Include this as an \\`export\\` to name it and make it accessible.\n   */\n  export const internalQuery = internalQueryGeneric;\n\n  /**\n   * Define a mutation in this Convex app's public API.\n   *\n   * This function will be allowed to modify your Convex database and will be accessible from the client.\n   *\n   * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.\n   * @returns The wrapped mutation. Include this as an \\`export\\` to name it and make it accessible.\n   */\n  export const mutation = mutationGeneric;\n\n  /**\n   * Define a mutation that is only accessible from other Convex functions (but not from the client).\n   *\n   * This function will be allowed to modify your Convex database. It will not be accessible from the client.\n   *\n   * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.\n   * @returns The wrapped mutation. Include this as an \\`export\\` to name it and make it accessible.\n   */\n  export const internalMutation = internalMutationGeneric;\n\n  /**\n   * Define an action in this Convex app's public API.\n   *\n   * An action is a function which can execute any JavaScript code, including non-deterministic\n   * code and code with side-effects, like calling third-party services.\n   * They can be run in Convex's JavaScript environment or in Node.js using the \"use node\" directive.\n   * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.\n   *\n   * @param func - The action. It receives an {@link ActionCtx} as its first argument.\n   * @returns The wrapped action. Include this as an \\`export\\` to name it and make it accessible.\n   */\n  export const action = actionGeneric;\n\n  /**\n   * Define an action that is only accessible from other Convex functions (but not from the client).\n   *\n   * @param func - The function. It receives an {@link ActionCtx} as its first argument.\n   * @returns The wrapped function. Include this as an \\`export\\` to name it and make it accessible.\n   */\n  export const internalAction = internalActionGeneric;\n\n  /**\n   * Define a Convex HTTP action.\n   *\n   * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a \\`Request\\` object\n   * as its second.\n   * @returns The wrapped endpoint function. Route a URL path to this function in \\`convex/http.js\\`.\n   */\n  export const httpAction = httpActionGeneric;\n\n  export const components = componentsGeneric();\n  `;\n  return result;\n}\n\nfunction componentServerDTSPrelude(_isRoot: boolean): string {\n  return `\n    ${header(\n      \"Generated utilities for implementing server-side Convex query and mutation functions.\",\n    )}\n    import {\n      ActionBuilder,\n      AnyComponents,\n      HttpActionBuilder,\n      MutationBuilder,\n      QueryBuilder,\n      GenericActionCtx,\n      GenericMutationCtx,\n      GenericQueryCtx,\n      GenericDatabaseReader,\n      GenericDatabaseWriter,\n      FunctionReference,\n    } from \"convex/server\";\n    import type { DataModel } from \"./dataModel.js\";\n\n    type GenericCtx = GenericActionCtx<DataModel> | GenericMutationCtx<DataModel> | GenericQueryCtx<DataModel>;\n\n    /**\n     * Define a query in this Convex app's public API.\n     *\n     * This function will be allowed to read your Convex database and will be accessible from the client.\n     *\n     * @param func - The query function. It receives a {@link QueryCtx} as its first argument.\n     * @returns The wrapped query. Include this as an \\`export\\` to name it and make it accessible.\n     */\n    export declare const query: QueryBuilder<DataModel, \"public\">;\n\n    /**\n     * Define a query that is only accessible from other Convex functions (but not from the client).\n     *\n     * This function will be allowed to read from your Convex database. It will not be accessible from the client.\n     *\n     * @param func - The query function. It receives a {@link QueryCtx} as its first argument.\n     * @returns The wrapped query. Include this as an \\`export\\` to name it and make it accessible.\n     */\n    export declare const internalQuery: QueryBuilder<DataModel, \"internal\">;\n\n    /**\n     * Define a mutation in this Convex app's public API.\n     *\n     * This function will be allowed to modify your Convex database and will be accessible from the client.\n     *\n     * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.\n     * @returns The wrapped mutation. Include this as an \\`export\\` to name it and make it accessible.\n     */\n    export declare const mutation: MutationBuilder<DataModel, \"public\">;\n\n    /**\n     * Define a mutation that is only accessible from other Convex functions (but not from the client).\n     *\n     * This function will be allowed to modify your Convex database. It will not be accessible from the client.\n     *\n     * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.\n     * @returns The wrapped mutation. Include this as an \\`export\\` to name it and make it accessible.\n     */\n    export declare const internalMutation: MutationBuilder<DataModel, \"internal\">;\n\n    /**\n     * Define an action in this Convex app's public API.\n     *\n     * An action is a function which can execute any JavaScript code, including non-deterministic\n     * code and code with side-effects, like calling third-party services.\n     * They can be run in Convex's JavaScript environment or in Node.js using the \"use node\" directive.\n     * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.\n     *\n     * @param func - The action. It receives an {@link ActionCtx} as its first argument.\n     * @returns The wrapped action. Include this as an \\`export\\` to name it and make it accessible.\n     */\n    export declare const action: ActionBuilder<DataModel, \"public\">;\n\n    /**\n     * Define an action that is only accessible from other Convex functions (but not from the client).\n     *\n     * @param func - The function. It receives an {@link ActionCtx} as its first argument.\n     * @returns The wrapped function. Include this as an \\`export\\` to name it and make it accessible.\n     */\n    export declare const internalAction: ActionBuilder<DataModel, \"internal\">;\n\n    /**\n     * Define an HTTP action.\n     *\n     * This function will be used to respond to HTTP requests received by a Convex\n     * deployment if the requests matches the path and method where this action\n     * is routed. Be sure to route your action in \\`convex/http.js\\`.\n     *\n     * @param func - The function. It receives an {@link ActionCtx} as its first argument.\n     * @returns The wrapped function. Import this function from \\`convex/http.js\\` and route it to hook it up.\n     */\n    export declare const httpAction: HttpActionBuilder;\n\n    /**\n     * A set of services for use within Convex query functions.\n     *\n     * The query context is passed as the first argument to any Convex query\n     * function run on the server.\n     *\n     * This differs from the {@link MutationCtx} because all of the services are\n     * read-only.\n     */\n    export type QueryCtx = GenericQueryCtx<DataModel>;\n\n    /**\n     * A set of services for use within Convex mutation functions.\n     *\n     * The mutation context is passed as the first argument to any Convex mutation\n     * function run on the server.\n     */\n    export type MutationCtx = GenericMutationCtx<DataModel>;\n\n    /**\n     * A set of services for use within Convex action functions.\n     *\n     * The action context is passed as the first argument to any Convex action\n     * function run on the server.\n     */\n    export type ActionCtx = GenericActionCtx<DataModel>;\n\n    /**\n     * An interface to read from the database within Convex query functions.\n     *\n     * The two entry points are {@link DatabaseReader.get}, which fetches a single\n     * document by its {@link Id}, or {@link DatabaseReader.query}, which starts\n     * building a query.\n     */\n    export type DatabaseReader = GenericDatabaseReader<DataModel>;\n\n    /**\n     * An interface to read from and write to the database within Convex mutation\n     * functions.\n     *\n     * Convex guarantees that all writes within a single mutation are\n     * executed atomically, so you never have to worry about partial writes leaving\n     * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)\n     * for the guarantees Convex provides your functions.\n     */\n    export type DatabaseWriter = GenericDatabaseWriter<DataModel>;\n  `;\n}\n\nexport function componentServerStubDTS(isRoot: boolean): string {\n  let result = componentServerDTSPrelude(isRoot);\n  result += `\n  export declare const components: AnyComponents;\n  `;\n  return result;\n}\n\nexport async function componentServerDTS(\n  ctx: Context,\n  startPush: StartPushResponse,\n  rootComponent: ComponentDirectory,\n  componentDirectory: ComponentDirectory,\n): Promise<string> {\n  const result = [componentServerDTSPrelude(componentDirectory.isRoot)];\n\n  result.push(`export declare const components: {`);\n\n  const definitionPath = toComponentDefinitionPath(\n    rootComponent,\n    componentDirectory,\n  );\n\n  const analysis = startPush.analysis[encodeDefinitionPath(definitionPath)];\n  if (!analysis) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `No analysis found for component ${encodeDefinitionPath(definitionPath as any)} orig: ${definitionPath}\\nin\\n${Object.keys(startPush.analysis).toString()}`,\n    });\n  }\n  for (const childComponent of analysis.definition.childComponents) {\n    const childComponentAnalysis = startPush.analysis[childComponent.path];\n    if (!childComponentAnalysis) {\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `No analysis found for child component ${childComponent.path}`,\n      });\n    }\n    for await (const line of codegenExports(\n      ctx,\n      childComponent.name,\n      childComponentAnalysis,\n    )) {\n      result.push(line);\n    }\n  }\n\n  result.push(\"};\");\n\n  return result.join(\"\\n\");\n}\n\nasync function* codegenExports(\n  ctx: Context,\n  name: Identifier,\n  analysis: EvaluatedComponentDefinition,\n): AsyncGenerator<string> {\n  yield `${name}: {`;\n  for (const [name, componentExport] of analysis.definition.exports.branch) {\n    yield `${name}:`;\n    yield* codegenExport(ctx, analysis, componentExport);\n    yield \",\";\n  }\n  yield \"},\";\n}\n\nasync function* codegenExport(\n  ctx: Context,\n  analysis: EvaluatedComponentDefinition,\n  componentExport: ComponentExports,\n): AsyncGenerator<string> {\n  if (componentExport.type === \"leaf\") {\n    yield await resolveFunctionReference(\n      ctx,\n      analysis,\n      componentExport.leaf,\n      \"internal\",\n    );\n  } else if (componentExport.type === \"branch\") {\n    yield \"{\";\n    for (const [name, childExport] of componentExport.branch) {\n      yield `${name}:`;\n      yield* codegenExport(ctx, analysis, childExport);\n      yield \",\";\n    }\n    yield \"}\";\n  }\n}\n\nexport async function resolveFunctionReference(\n  ctx: Context,\n  analysis: EvaluatedComponentDefinition,\n  reference: Reference,\n  visibility: \"public\" | \"internal\",\n) {\n  if (!reference.startsWith(\"_reference/function/\")) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Invalid function reference: ${reference}`,\n    });\n  }\n  const udfPath = reference.slice(\"_reference/function/\".length);\n\n  const [modulePath, functionName] = udfPath.split(\":\");\n  const canonicalizedModulePath = canonicalizeModulePath(modulePath);\n\n  const analyzedModule = analysis.functions[canonicalizedModulePath];\n  if (!analyzedModule) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Module not found: ${modulePath}`,\n    });\n  }\n  const analyzedFunction = analyzedModule.functions.find(\n    (f) => f.name === functionName,\n  );\n  if (!analyzedFunction) {\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Function not found: ${functionName}`,\n    });\n  }\n\n  // The server sends down `udfType` capitalized.\n  const udfType = analyzedFunction.udfType.toLowerCase();\n\n  const argsValidator = parseValidator(analyzedFunction.args);\n  let argsType = \"any\";\n  if (argsValidator) {\n    if (argsValidator.type === \"object\" || argsValidator.type === \"any\") {\n      argsType = validatorToType(argsValidator);\n    } else {\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"fatal\",\n        printedMessage: `Invalid function args: ${analyzedFunction.args}`,\n      });\n    }\n  }\n\n  const returnsValidator = parseValidator(analyzedFunction.returns);\n  let returnsType = \"any\";\n  if (returnsValidator) {\n    returnsType = validatorToType(returnsValidator);\n  }\n\n  return `FunctionReference<\"${udfType}\", \"${visibility}\", ${argsType}, ${returnsType}>`;\n}\n\nfunction parseValidator(validator: string | null): ConvexValidator | null {\n  if (!validator) {\n    return null;\n  }\n  return z.nullable(convexValidator).parse(JSON.parse(validator));\n}\n\nfunction canonicalizeModulePath(modulePath: string): CanonicalizedModulePath {\n  if (!modulePath.endsWith(\".js\")) {\n    return modulePath + \".js\";\n  }\n  return modulePath;\n}\n\nfunction validatorToType(validator: ConvexValidator): string {\n  if (validator.type === \"null\") {\n    return \"null\";\n  } else if (validator.type === \"number\") {\n    return \"number\";\n  } else if (validator.type === \"bigint\") {\n    return \"bigint\";\n  } else if (validator.type === \"boolean\") {\n    return \"boolean\";\n  } else if (validator.type === \"string\") {\n    return \"string\";\n  } else if (validator.type === \"bytes\") {\n    return \"ArrayBuffer\";\n  } else if (validator.type === \"any\") {\n    return \"any\";\n  } else if (validator.type === \"literal\") {\n    const convexValue = jsonToConvex(validator.value);\n    return convexValueToLiteral(convexValue);\n  } else if (validator.type === \"id\") {\n    return \"string\";\n  } else if (validator.type === \"array\") {\n    return `Array<${validatorToType(validator.value)}>`;\n  } else if (validator.type === \"record\") {\n    return `Record<${validatorToType(validator.keys)}, ${validatorToType(validator.values)}>`;\n  } else if (validator.type === \"union\") {\n    return validator.value.map(validatorToType).join(\" | \");\n  } else if (validator.type === \"object\") {\n    return objectValidatorToType(validator.value);\n  } else {\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`Unsupported validator type`);\n  }\n}\n\nfunction objectValidatorToType(\n  fields: Record<string, { fieldType: ConvexValidator; optional: boolean }>,\n): string {\n  const fieldStrings: string[] = [];\n  for (const [fieldName, field] of Object.entries(fields)) {\n    const fieldType = validatorToType(field.fieldType);\n    fieldStrings.push(`${fieldName}${field.optional ? \"?\" : \"\"}: ${fieldType}`);\n  }\n  return `{ ${fieldStrings.join(\", \")} }`;\n}\n\nfunction convexValueToLiteral(value: Value): string {\n  if (value === null) {\n    return \"null\";\n  }\n  if (typeof value === \"bigint\") {\n    return `${value}n`;\n  }\n  if (typeof value === \"number\") {\n    return `${value}`;\n  }\n  if (typeof value === \"boolean\") {\n    return `${value}`;\n  }\n  if (typeof value === \"string\") {\n    return `\"${value}\"`;\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  throw new Error(`Unsupported literal type`);\n}\n"],
  "mappings": "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",
  "names": ["name"]
}
