{
  "version": 3,
  "sources": ["../../../src/cli/convexExport.ts"],
  "sourcesContent": ["import { Command, Option } from \"@commander-js/extra-typings\";\nimport chalk from \"chalk\";\nimport {\n  ensureHasConvexDependency,\n  waitUntilCalled,\n  deploymentFetch,\n  logAndHandleFetchError,\n} from \"./lib/utils/utils.js\";\nimport {\n  logFailure,\n  oneoffContext,\n  Context,\n  showSpinner,\n  logFinishedStep,\n  logError,\n  stopSpinner,\n  changeSpinner,\n} from \"../bundler/context.js\";\nimport {\n  fetchDeploymentCredentialsProvisionProd,\n  deploymentSelectionFromOptions,\n} from \"./lib/api.js\";\nimport { subscribe } from \"./lib/run.js\";\nimport { nodeFs } from \"../bundler/fs.js\";\nimport path from \"path\";\nimport { deploymentDashboardUrlPage } from \"./dashboard.js\";\nimport { actionDescription } from \"./lib/command.js\";\nimport { Readable } from \"stream\";\n\nexport const convexExport = new Command(\"export\")\n  .summary(\"Export data from your deployment to a ZIP file\")\n  .description(\n    \"Export data, and optionally file storage, from your Convex deployment to a ZIP file.\\n\" +\n      \"By default, this exports from your dev deployment.\",\n  )\n  .requiredOption(\n    \"--path <zipFilePath>\",\n    \"Exports data into a ZIP file at this path, which may be a directory or unoccupied .zip path\",\n  )\n  .addOption(\n    new Option(\n      \"--include-file-storage\",\n      \"Includes stored files (https://dashboard.convex.dev/deployment/files) in a _storage folder within the ZIP file\",\n    ),\n  )\n  .addDeploymentSelectionOptions(actionDescription(\"Export data from\"))\n  .showHelpAfterError()\n  .action(async (options) => {\n    const ctx = oneoffContext();\n\n    const deploymentSelection = deploymentSelectionFromOptions(options);\n\n    const {\n      adminKey,\n      url: deploymentUrl,\n      deploymentName,\n    } = await fetchDeploymentCredentialsProvisionProd(ctx, deploymentSelection);\n\n    const inputPath = options.path;\n    const includeStorage = !!options.includeFileStorage;\n\n    await ensureHasConvexDependency(ctx, \"export\");\n\n    const deploymentNotice = options.prod\n      ? ` in your ${chalk.bold(\"prod\")} deployment`\n      : \"\";\n    showSpinner(ctx, `Creating snapshot export${deploymentNotice}`);\n\n    const snapshotExportState = await startSnapshotExport(ctx, {\n      includeStorage,\n      inputPath,\n      adminKey,\n      deploymentUrl,\n      deploymentName: deploymentName ?? null,\n    });\n\n    switch (snapshotExportState.state) {\n      case \"completed\":\n        stopSpinner(ctx);\n        logFinishedStep(\n          ctx,\n          `Created snapshot export at timestamp ${snapshotExportState.start_ts}`,\n        );\n        logFinishedStep(\n          ctx,\n          `Export is available at ${await deploymentDashboardUrlPage(\n            deploymentName ?? null,\n            \"/settings/snapshot-export\",\n          )}`,\n        );\n        break;\n      case \"requested\":\n      case \"in_progress\": {\n        return await ctx.crash({\n          exitCode: 1,\n          errorType: \"fatal\",\n          printedMessage: `WARNING: Export is continuing to run on the server.`,\n        });\n      }\n      default: {\n        const _: never = snapshotExportState;\n        return await ctx.crash({\n          exitCode: 1,\n          errorType: \"fatal\",\n          printedMessage: `unknown error: unexpected state ${snapshotExportState as any}`,\n          errForSentry: `unexpected snapshot export state ${(snapshotExportState as any).state}`,\n        });\n      }\n    }\n\n    showSpinner(ctx, `Downloading snapshot export to ${chalk.bold(inputPath)}`);\n    const { filePath } = await downloadSnapshotExport(ctx, {\n      snapshotExportTs: snapshotExportState.start_ts,\n      inputPath,\n      adminKey,\n      deploymentUrl,\n    });\n    stopSpinner(ctx);\n    logFinishedStep(\n      ctx,\n      `Downloaded snapshot export to ${chalk.bold(filePath)}`,\n    );\n  });\n\ntype SnapshotExportState =\n  | { state: \"requested\" }\n  | { state: \"in_progress\" }\n  | {\n      state: \"completed\";\n      complete_ts: bigint;\n      start_ts: bigint;\n      zip_object_key: string;\n    };\n\nasync function waitForStableExportState(\n  ctx: Context,\n  deploymentUrl: string,\n  adminKey: string,\n): Promise<SnapshotExportState> {\n  const [donePromise, onDone] = waitUntilCalled();\n  let snapshotExportState: SnapshotExportState;\n  await subscribe(\n    ctx,\n    deploymentUrl,\n    adminKey,\n    \"_system/cli/exports:getLatest\",\n    {},\n    undefined,\n    donePromise,\n    {\n      onChange: (value: any) => {\n        // NOTE: `value` would only be `null` if there has never been an export\n        // requested.\n        snapshotExportState = value;\n        switch (snapshotExportState.state) {\n          case \"requested\":\n          case \"in_progress\":\n            // Not a stable state.\n            break;\n          case \"completed\":\n            onDone();\n            break;\n          default: {\n            const _: never = snapshotExportState;\n            onDone();\n          }\n        }\n      },\n    },\n  );\n  return snapshotExportState!;\n}\n\nexport async function startSnapshotExport(\n  ctx: Context,\n  args: {\n    includeStorage: boolean;\n    inputPath: string;\n    adminKey: string;\n    deploymentUrl: string;\n    deploymentName: string | null;\n  },\n) {\n  const fetch = deploymentFetch(args.deploymentUrl, args.adminKey);\n  try {\n    await fetch(\n      `/api/export/request/zip?includeStorage=${args.includeStorage}`,\n      {\n        method: \"POST\",\n      },\n    );\n  } catch (e) {\n    return await logAndHandleFetchError(ctx, e);\n  }\n\n  const snapshotExportState = await waitForStableExportState(\n    ctx,\n    args.deploymentUrl,\n    args.adminKey,\n  );\n  return snapshotExportState;\n}\n\nexport async function downloadSnapshotExport(\n  ctx: Context,\n  args: {\n    snapshotExportTs: bigint;\n    inputPath: string;\n    adminKey: string;\n    deploymentUrl: string;\n  },\n): Promise<{ filePath: string }> {\n  const inputPath = args.inputPath;\n  const exportUrl = `/api/export/zip/${args.snapshotExportTs.toString()}?adminKey=${encodeURIComponent(\n    args.adminKey,\n  )}`;\n  const fetch = deploymentFetch(args.deploymentUrl, args.adminKey);\n  let response: Response;\n  try {\n    response = await fetch(exportUrl, {\n      method: \"GET\",\n    });\n  } catch (e) {\n    return await logAndHandleFetchError(ctx, e);\n  }\n\n  let filePath;\n  if (ctx.fs.exists(inputPath)) {\n    const st = ctx.fs.stat(inputPath);\n    if (st.isDirectory()) {\n      const contentDisposition =\n        response.headers.get(\"content-disposition\") ?? \"\";\n      let filename = `snapshot_${args.snapshotExportTs.toString()}.zip`;\n      if (contentDisposition.startsWith(\"attachment; filename=\")) {\n        filename = contentDisposition.slice(\"attachment; filename=\".length);\n      }\n      filePath = path.join(inputPath, filename);\n    } else {\n      // TODO(sarah) -- if this is called elsewhere, I'd like to catch the error + potentially\n      // have different logging\n      return await ctx.crash({\n        exitCode: 1,\n        errorType: \"invalid filesystem data\",\n        printedMessage: `Error: Path ${chalk.bold(inputPath)} already exists.`,\n      });\n    }\n  } else {\n    filePath = inputPath;\n  }\n  changeSpinner(ctx, `Downloading snapshot export to ${chalk.bold(filePath)}`);\n\n  try {\n    await nodeFs.writeFileStream(\n      filePath,\n      Readable.fromWeb(response.body! as any),\n    );\n  } catch (e) {\n    logFailure(ctx, `Exporting data failed`);\n    logError(ctx, chalk.red(e));\n    return await ctx.crash({\n      exitCode: 1,\n      errorType: \"fatal\",\n      printedMessage: `Exporting data failed: ${chalk.red(e)}`,\n    });\n  }\n  return { filePath };\n}\n"],
  "mappings": "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",
  "names": []
}
