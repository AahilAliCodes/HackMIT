"use strict";
import { logVerbose } from "../../../bundler/context.js";
import detect from "detect-port";
import {
  bigBrainPause,
  bigBrainRecordActivity,
  bigBrainStart
} from "./bigBrain.js";
import {
  loadDeploymentConfig,
  rootDeploymentStateDir,
  saveDeploymentConfig
} from "./filePaths.js";
import {
  ensureBackendBinaryDownloaded,
  ensureBackendRunning,
  ensureBackendStopped,
  localDeploymentUrl,
  runLocalBackend
} from "./run.js";
import { handlePotentialUpgrade } from "./upgrade.js";
import { promptSearch } from "../utils/prompts.js";
export async function handleLocalDeployment(ctx, options) {
  if (await isOffline()) {
    return handleOffline(ctx, options);
  }
  const existingDeploymentForProject = await getExistingDeployment(ctx, {
    projectSlug: options.projectSlug,
    teamSlug: options.teamSlug
  });
  if (existingDeploymentForProject !== null) {
    logVerbose(
      ctx,
      `Found existing deployment for project ${options.projectSlug}`
    );
    await ensureBackendStopped(ctx, {
      ports: {
        cloud: existingDeploymentForProject.config.ports.cloud
      },
      maxTimeSecs: 5,
      deploymentName: existingDeploymentForProject.deploymentName,
      allowOtherDeployments: true
    });
  }
  const { binaryPath, version } = await ensureBackendBinaryDownloaded(
    ctx,
    options.backendVersion === void 0 ? {
      kind: "latest"
    } : { kind: "version", version: options.backendVersion }
  );
  const ports = await choosePorts(ctx, options.ports);
  const { deploymentName, adminKey } = await bigBrainStart(ctx, {
    port: ports.cloud,
    projectSlug: options.projectSlug,
    teamSlug: options.teamSlug,
    instanceName: existingDeploymentForProject?.deploymentName ?? null
  });
  const onActivity = async (isOffline2, _wasOffline) => {
    await ensureBackendRunning(ctx, {
      cloudPort: ports.cloud,
      deploymentName,
      maxTimeSecs: 5
    });
    if (isOffline2) {
      return;
    }
    await bigBrainRecordActivity(ctx, {
      instanceName: deploymentName
    });
  };
  const { cleanupHandle } = await handlePotentialUpgrade(ctx, {
    deploymentName,
    oldVersion: existingDeploymentForProject?.config.backendVersion ?? null,
    newBinaryPath: binaryPath,
    newVersion: version,
    ports,
    adminKey,
    forceUpgrade: options.forceUpgrade
  });
  const cleanupFunc = ctx.removeCleanup(cleanupHandle);
  ctx.registerCleanup(async () => {
    if (cleanupFunc !== null) {
      await cleanupFunc();
    }
    await bigBrainPause(ctx, {
      projectSlug: options.projectSlug,
      teamSlug: options.teamSlug
    });
  });
  return {
    adminKey,
    deploymentName,
    deploymentUrl: localDeploymentUrl(ports.cloud),
    onActivity
  };
}
async function handleOffline(ctx, options) {
  const { deploymentName, config } = await chooseFromExistingLocalDeployments(ctx);
  const { binaryPath } = await ensureBackendBinaryDownloaded(ctx, {
    kind: "version",
    version: config.backendVersion
  });
  const ports = await choosePorts(ctx, options.ports);
  saveDeploymentConfig(ctx, deploymentName, config);
  await runLocalBackend(ctx, {
    binaryPath,
    ports,
    deploymentName
  });
  return {
    adminKey: config.adminKey,
    deploymentName,
    deploymentUrl: localDeploymentUrl(ports.cloud),
    onActivity: async (isOffline2, wasOffline) => {
      await ensureBackendRunning(ctx, {
        cloudPort: ports.cloud,
        deploymentName,
        maxTimeSecs: 5
      });
      if (isOffline2) {
        return;
      }
      if (wasOffline) {
        await bigBrainStart(ctx, {
          port: ports.cloud,
          projectSlug: options.projectSlug,
          teamSlug: options.teamSlug,
          instanceName: deploymentName
        });
      }
      await bigBrainRecordActivity(ctx, {
        instanceName: deploymentName
      });
    }
  };
}
async function getExistingDeployment(ctx, options) {
  const { projectSlug, teamSlug } = options;
  const prefix = `local-${teamSlug.replace(/-/g, "_")}-${projectSlug.replace(/-/g, "_")}`;
  const localDeployments = await getLocalDeployments(ctx);
  const existingDeploymentForProject = localDeployments.find(
    (d) => d.deploymentName.startsWith(prefix)
  );
  if (existingDeploymentForProject === void 0) {
    return null;
  }
  return {
    deploymentName: existingDeploymentForProject.deploymentName,
    config: existingDeploymentForProject.config
  };
}
async function getLocalDeployments(ctx) {
  const dir = rootDeploymentStateDir();
  if (!ctx.fs.exists(dir)) {
    return [];
  }
  const deploymentNames = ctx.fs.listDir(dir).map((d) => d.name);
  return deploymentNames.flatMap((deploymentName) => {
    const config = loadDeploymentConfig(ctx, deploymentName);
    if (config !== null) {
      return [{ deploymentName, config }];
    }
    return [];
  });
}
async function chooseFromExistingLocalDeployments(ctx) {
  const localDeployments = await getLocalDeployments(ctx);
  return promptSearch(ctx, {
    message: "Choose from an existing local deployment?",
    choices: localDeployments.map((d) => ({
      name: d.deploymentName,
      value: d
    }))
  });
}
async function choosePorts(ctx, requestedPorts) {
  if (requestedPorts !== void 0) {
    const availableCloudPort2 = await detect(requestedPorts.cloud);
    const availableSitePort2 = await detect(requestedPorts.site);
    if (availableCloudPort2 !== requestedPorts.cloud || availableSitePort2 !== requestedPorts.site) {
      return ctx.crash({
        exitCode: 1,
        errorType: "fatal",
        printedMessage: "Requested ports are not available"
      });
    }
    return { cloud: availableCloudPort2, site: availableSitePort2 };
  }
  const availableCloudPort = await detect(3210);
  const availableSitePort = await detect(availableCloudPort + 1);
  return { cloud: availableCloudPort, site: availableSitePort };
}
async function isOffline() {
  return false;
}
//# sourceMappingURL=localDeployment.js.map
