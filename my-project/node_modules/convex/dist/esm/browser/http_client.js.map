{
  "version": 3,
  "sources": ["../../../src/browser/http_client.ts"],
  "sourcesContent": ["import {\n  FunctionReference,\n  FunctionReturnType,\n  OptionalRestArgs,\n  getFunctionName,\n} from \"../server/api.js\";\nimport { parseArgs, validateDeploymentUrl } from \"../common/index.js\";\nimport { version } from \"../index.js\";\nimport {\n  ConvexError,\n  JSONValue,\n  convexToJson,\n  jsonToConvex,\n} from \"../values/index.js\";\nimport { logToConsole } from \"./logging.js\";\nimport { FunctionArgs, UserIdentityAttributes } from \"../server/index.js\";\n\nexport const STATUS_CODE_OK = 200;\nexport const STATUS_CODE_BAD_REQUEST = 400;\n// Special custom 5xx HTTP status code to mean that the UDF returned an error.\n//\n// Must match the constant of the same name in the backend.\nexport const STATUS_CODE_UDF_FAILED = 560;\n\n// Allow fetch to be shimmed in for Node.js < 18\nlet specifiedFetch: typeof globalThis.fetch | undefined = undefined;\nexport function setFetch(f: typeof globalThis.fetch) {\n  specifiedFetch = f;\n}\n\n/**\n * A Convex client that runs queries and mutations over HTTP.\n *\n * This is appropriate for server-side code (like Netlify Lambdas) or non-reactive\n * webapps.\n *\n * If you're building a React app, consider using\n * {@link react.ConvexReactClient} instead.\n *\n * @public\n */\nexport class ConvexHttpClient {\n  private readonly address: string;\n  private auth?: string;\n  private adminAuth?: string;\n  private encodedTsPromise?: Promise<string>;\n  private debug: boolean;\n  private fetchOptions?: FetchOptions;\n\n  /**\n   * Create a new {@link ConvexHttpClient}.\n   *\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param skipConvexDeploymentUrlCheck - Skip validating that the Convex deployment URL looks like\n   * `https://happy-animal-123.convex.cloud` or localhost. This can be useful if running a self-hosted\n   * Convex backend that uses a different URL.\n   */\n  constructor(address: string, skipConvexDeploymentUrlCheck?: boolean) {\n    if (skipConvexDeploymentUrlCheck !== true) {\n      validateDeploymentUrl(address);\n    }\n    this.address = address;\n    this.debug = true;\n  }\n\n  /**\n   * Obtain the {@link ConvexHttpClient}'s URL to its backend.\n   * @deprecated Use url, which returns the url without /api at the end.\n   *\n   * @returns The URL to the Convex backend, including the client's API version.\n   */\n  backendUrl(): string {\n    return `${this.address}/api`;\n  }\n\n  /**\n   * Return the address for this client, useful for creating a new client.\n   *\n   * Not guaranteed to match the address with which this client was constructed:\n   * it may be canonicalized.\n   */\n  get url() {\n    return this.address;\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   *\n   * Should be called whenever the token changes (i.e. due to expiration and refresh).\n   *\n   * @param value - JWT-encoded OpenID Connect identity token.\n   */\n  setAuth(value: string) {\n    this.clearAuth();\n    this.auth = value;\n  }\n\n  /**\n   * @internal\n   */\n  setAdminAuth(token: string, actingAsIdentity?: UserIdentityAttributes) {\n    this.clearAuth();\n    if (actingAsIdentity !== undefined) {\n      // Encode the identity to a base64 string\n      const bytes = new TextEncoder().encode(JSON.stringify(actingAsIdentity));\n      const actingAsIdentityEncoded = btoa(String.fromCodePoint(...bytes));\n      this.adminAuth = `${token}:${actingAsIdentityEncoded}`;\n    } else {\n      this.adminAuth = token;\n    }\n  }\n\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.auth = undefined;\n    this.adminAuth = undefined;\n  }\n\n  /**\n   * Sets whether the result log lines should be printed on the console or not.\n   *\n   * @internal\n   */\n  setDebug(debug: boolean) {\n    this.debug = debug;\n  }\n\n  /**\n   * Used to customize the fetch behavior in some runtimes.\n   *\n   * @internal\n   */\n  setFetchOptions(fetchOptions: FetchOptions) {\n    this.fetchOptions = fetchOptions;\n  }\n\n  /**\n   * This API is experimental: it may change or disappear.\n   *\n   * Execute a Convex query function at the same timestamp as every other\n   * consistent query execution run by this HTTP client.\n   *\n   * This doesn't make sense for long-lived ConvexHttpClients as Convex\n   * backends can read a limited amount into the past: beyond 30 seconds\n   * in the past may not be available.\n   *\n   * Create a new client to use a consistent time.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   *\n   * @deprecated This API is experimental: it may change or disappear.\n   */\n  async consistentQuery<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    ...args: OptionalRestArgs<Query>\n  ): Promise<FunctionReturnType<Query>> {\n    const queryArgs = parseArgs(args[0]);\n\n    const timestampPromise = this.getTimestamp();\n    return await this.queryInner(query, queryArgs, { timestampPromise });\n  }\n\n  private async getTimestamp() {\n    if (this.encodedTsPromise) {\n      return this.encodedTsPromise;\n    }\n    return (this.encodedTsPromise = this.getTimestampInner());\n  }\n\n  private async getTimestampInner() {\n    const localFetch = specifiedFetch || fetch;\n\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    const response = await localFetch(`${this.address}/api/query_ts`, {\n      ...this.fetchOptions,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok) {\n      throw new Error(await response.text());\n    }\n    const { ts } = (await response.json()) as { ts: string };\n    return ts;\n  }\n\n  /**\n   * Execute a Convex query function.\n   *\n   * @param name - The name of the query.\n   * @param args - The arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   */\n  async query<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    ...args: OptionalRestArgs<Query>\n  ): Promise<FunctionReturnType<Query>> {\n    const queryArgs = parseArgs(args[0]);\n    return await this.queryInner(query, queryArgs, {});\n  }\n\n  private async queryInner<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    queryArgs: FunctionArgs<Query>,\n    options: { timestampPromise?: Promise<string> },\n  ): Promise<FunctionReturnType<Query>> {\n    const name = getFunctionName(query);\n    const args = [convexToJson(queryArgs)];\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n\n    const timestamp = options.timestampPromise\n      ? await options.timestampPromise\n      : undefined;\n\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args,\n      ...(timestamp ? { ts: timestamp } : {}),\n    });\n    const endpoint = timestamp\n      ? `${this.address}/api/query_at_ts`\n      : `${this.address}/api/query`;\n\n    const response = await localFetch(endpoint, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"query\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== undefined) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage),\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n\n  /**\n   * Execute a Convex mutation function.\n   *\n   * @param name - The name of the mutation.\n   * @param args - The arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the mutation's result.\n   */\n  async mutation<Mutation extends FunctionReference<\"mutation\">>(\n    mutation: Mutation,\n    ...args: OptionalRestArgs<Mutation>\n  ): Promise<FunctionReturnType<Mutation>> {\n    const mutationArgs = parseArgs(args[0]);\n    const name = getFunctionName(mutation);\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args: [convexToJson(mutationArgs)],\n    });\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/mutation`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"mutation\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== undefined) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage),\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n\n  /**\n   * Execute a Convex action function.\n   *\n   * @param name - The name of the action.\n   * @param args - The arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  async action<Action extends FunctionReference<\"action\">>(\n    action: Action,\n    ...args: OptionalRestArgs<Action>\n  ): Promise<FunctionReturnType<Action>> {\n    const actionArgs = parseArgs(args[0]);\n    const name = getFunctionName(action);\n    const body = JSON.stringify({\n      path: name,\n      format: \"convex_encoded_json\",\n      args: [convexToJson(actionArgs)],\n    });\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/action`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"action\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== undefined) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage),\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n\n  /**\n   * Execute a Convex function of an unknown type.\n   *\n   * @param name - The name of the function.\n   * @param args - The arguments object for the function. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the function's result.\n   *\n   * @internal\n   */\n  async function<\n    AnyFunction extends FunctionReference<\"query\" | \"mutation\" | \"action\">,\n  >(\n    anyFunction: AnyFunction | string,\n    componentPath?: string,\n    ...args: OptionalRestArgs<AnyFunction>\n  ): Promise<FunctionReturnType<AnyFunction>> {\n    const functionArgs = parseArgs(args[0]);\n    const name =\n      typeof anyFunction === \"string\"\n        ? anyFunction\n        : getFunctionName(anyFunction);\n    const body = JSON.stringify({\n      componentPath: componentPath,\n      path: name,\n      format: \"convex_encoded_json\",\n      args: convexToJson(functionArgs),\n    });\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"Convex-Client\": `npm-${version}`,\n    };\n    if (this.adminAuth) {\n      headers[\"Authorization\"] = `Convex ${this.adminAuth}`;\n    } else if (this.auth) {\n      headers[\"Authorization\"] = `Bearer ${this.auth}`;\n    }\n    const localFetch = specifiedFetch || fetch;\n    const response = await localFetch(`${this.address}/api/function`, {\n      ...this.fetchOptions,\n      body,\n      method: \"POST\",\n      headers: headers,\n      credentials: \"include\",\n    });\n    if (!response.ok && response.status !== STATUS_CODE_UDF_FAILED) {\n      throw new Error(await response.text());\n    }\n    const respJSON = await response.json();\n    if (this.debug) {\n      for (const line of respJSON.logLines ?? []) {\n        logToConsole(\"info\", \"any\", name, line);\n      }\n    }\n    switch (respJSON.status) {\n      case \"success\":\n        return jsonToConvex(respJSON.value);\n      case \"error\":\n        if (respJSON.errorData !== undefined) {\n          throw forwardErrorData(\n            respJSON.errorData,\n            new ConvexError(respJSON.errorMessage),\n          );\n        }\n        throw new Error(respJSON.errorMessage);\n      default:\n        throw new Error(`Invalid response: ${JSON.stringify(respJSON)}`);\n    }\n  }\n}\n\nfunction forwardErrorData(errorData: JSONValue, error: ConvexError<string>) {\n  (error as ConvexError<any>).data = jsonToConvex(errorData);\n  return error;\n}\n\n/**\n * @internal\n */\ntype FetchOptions = { cache: \"force-cache\" | \"no-store\" };\n"],
  "mappings": "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",
  "names": []
}
