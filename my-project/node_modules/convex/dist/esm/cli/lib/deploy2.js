"use strict";
import {
  changeSpinner,
  logError,
  logFailure
} from "../../bundler/context.js";
import {
  deploymentFetch,
  logAndHandleFetchError,
  ThrowingFetchError
} from "./utils/utils.js";
import {
  schemaStatus,
  startPushResponse
} from "./deployApi/startPush.js";
import chalk from "chalk";
import { getTargetDeploymentName } from "./deployment.js";
import { deploymentDashboardUrlPage } from "../dashboard.js";
import { finishPushDiff } from "./deployApi/finishPush.js";
export async function startPush(ctx, span, request, options) {
  if (options.verbose) {
    const custom = (_k, s) => typeof s === "string" ? s.slice(0, 40) + (s.length > 40 ? "..." : "") : s;
    console.log(JSON.stringify(request, custom, 2));
  }
  const onError = (err) => {
    if (err.toString() === "TypeError: fetch failed") {
      changeSpinner(
        ctx,
        `Fetch failed, is ${options.url} correct? Retrying...`
      );
    }
  };
  const fetch = deploymentFetch(options.url, request.adminKey, onError);
  changeSpinner(ctx, "Analyzing and deploying source code...");
  try {
    const response = await fetch("/api/deploy2/start_push", {
      body: JSON.stringify(request),
      method: "POST",
      headers: {
        traceparent: span.encodeW3CTraceparent()
      }
    });
    return startPushResponse.parse(await response.json());
  } catch (error) {
    const data = error instanceof ThrowingFetchError ? error.serverErrorData : void 0;
    if (data?.code === "AuthConfigMissingEnvironmentVariable") {
      const errorMessage = data.message || "(no error message given)";
      const configuredDeployment = getTargetDeploymentName();
      const [, variableName] = errorMessage.match(/Environment variable (\S+)/i) ?? [];
      const variableQuery = variableName !== void 0 ? `?var=${variableName}` : "";
      const dashboardUrl = deploymentDashboardUrlPage(
        configuredDeployment,
        `/settings/environment-variables${variableQuery}`
      );
      const message = `Environment variable ${chalk.bold(
        variableName
      )} is used in auth config file but its value was not set. Go to:

    ${chalk.bold(
        dashboardUrl
      )}

  to set it up. `;
      await ctx.crash({
        exitCode: 1,
        errorType: "invalid filesystem or env vars",
        errForSentry: error,
        printedMessage: message
      });
    }
    logFailure(ctx, "Error: Unable to start push to " + options.url);
    return await logAndHandleFetchError(ctx, error);
  }
}
const SCHEMA_TIMEOUT_MS = 1e4;
export async function waitForSchema(ctx, span, startPush2, options) {
  const fetch = deploymentFetch(options.url, options.adminKey);
  changeSpinner(
    ctx,
    "Backfilling indexes and checking that documents match your schema..."
  );
  while (true) {
    let currentStatus;
    try {
      const response = await fetch("/api/deploy2/wait_for_schema", {
        body: JSON.stringify({
          adminKey: options.adminKey,
          schemaChange: startPush2.schemaChange,
          timeoutMs: SCHEMA_TIMEOUT_MS,
          dryRun: options.dryRun
        }),
        method: "POST",
        headers: {
          traceparent: span.encodeW3CTraceparent()
        }
      });
      currentStatus = schemaStatus.parse(await response.json());
    } catch (error) {
      logFailure(ctx, "Error: Unable to wait for schema from " + options.url);
      return await logAndHandleFetchError(ctx, error);
    }
    switch (currentStatus.type) {
      case "inProgress": {
        let schemaDone = true;
        let indexesComplete = 0;
        let indexesTotal = 0;
        for (const componentStatus of Object.values(currentStatus.components)) {
          if (!componentStatus.schemaValidationComplete) {
            schemaDone = false;
          }
          indexesComplete += componentStatus.indexesComplete;
          indexesTotal += componentStatus.indexesTotal;
        }
        const indexesDone = indexesComplete === indexesTotal;
        let msg;
        if (!indexesDone && !schemaDone) {
          msg = `Backfilling indexes (${indexesComplete}/${indexesTotal} ready) and checking that documents match your schema...`;
        } else if (!indexesDone) {
          msg = `Backfilling indexes (${indexesComplete}/${indexesTotal} ready)...`;
        } else {
          msg = "Checking that documents match your schema...";
        }
        changeSpinner(ctx, msg);
        break;
      }
      case "failed": {
        let msg = "Schema validation failed";
        if (currentStatus.componentPath) {
          msg += ` in component "${currentStatus.componentPath}"`;
        }
        msg += ".";
        logFailure(ctx, msg);
        logError(ctx, chalk.red(`${currentStatus.error}`));
        return await ctx.crash({
          exitCode: 1,
          errorType: {
            "invalid filesystem or db data": currentStatus.tableName ? {
              tableName: currentStatus.tableName,
              componentPath: currentStatus.componentPath
            } : null
          },
          printedMessage: null
          // TODO - move logging into here
        });
      }
      case "raceDetected": {
        return await ctx.crash({
          exitCode: 1,
          errorType: "fatal",
          printedMessage: `Schema was overwritten by another push.`
        });
      }
      case "complete": {
        changeSpinner(ctx, "Schema validation complete.");
        return;
      }
    }
  }
}
export async function finishPush(ctx, span, startPush2, options) {
  changeSpinner(ctx, "Finalizing push...");
  const fetch = deploymentFetch(options.url, options.adminKey);
  try {
    const response = await fetch("/api/deploy2/finish_push", {
      body: JSON.stringify({
        adminKey: options.adminKey,
        startPush: startPush2,
        dryRun: options.dryRun
      }),
      method: "POST",
      headers: {
        traceparent: span.encodeW3CTraceparent()
      }
    });
    return finishPushDiff.parse(await response.json());
  } catch (error) {
    logFailure(ctx, "Error: Unable to finish push to " + options.url);
    return await logAndHandleFetchError(ctx, error);
  }
}
export async function reportPushCompleted(ctx, adminKey, url, reporter) {
  const fetch = deploymentFetch(url, adminKey);
  try {
    const response = await fetch("/api/deploy2/report_push_completed", {
      body: JSON.stringify({
        adminKey,
        spans: reporter.spans
      }),
      method: "POST"
    });
    await response.json();
  } catch (error) {
    logFailure(
      ctx,
      "Error: Unable to report push completed to " + url + ": " + error
    );
  }
}
//# sourceMappingURL=deploy2.js.map
